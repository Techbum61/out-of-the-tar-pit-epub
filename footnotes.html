<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Out of the Tar Pit</title>
    <meta name="author" content="Ben Moseley and Peter Marks"/>
    <meta name="keywords" content="Complexity, SoftwareEngineering, RelationalModel, Functional, FunctionalProgramming"/>
    <meta name="subject" content="Complexity"/>
    <meta content="http://www.w3.org/1999/xhtml; charset=utf-8" http-equiv="Content-Type"/>
    <link href="stylesheet.css" type="text/css" rel="stylesheet"/>
  </head>
  <body class="calibre">
    <h2>Footnotes</h2>
    <dl>
      <dt id="footnote-1">1</dt>
      <dd>By “state” we mean mutable state specifically — i.e. excluding things
	like (immutable) single-assignment variables which are provided by logic
	programming languages for example</dd>
      <dt id="footnote-2">2</dt>
      <dd>Indeed early versions of the Oz language (with implicit concurrency at
	the statement level) were somewhat of this kind
	[<a href="references.html#vRH04" class="calibre2">vRH04</a>].</dd>
      <dt id="footnote-3">3</dt>
      <dd>Particularly unnecessary data abstraction. We examine an argument that
	this is actually most data abstraction
	in <a href="index_split_000.html#dummy" class="calibre2">section
	9.2.4.</a></dd>
      <dt id="footnote-4">4</dt>
      <dd>This particular problem doesn’t really apply to object-oriented
	languages (such as CLOS) which are based upon generic functions — but
	they don’t have the same concept of encapsulation.</dd>
      <dt id="footnote-5">5</dt>
      <dd>We are using the term here to cover everything apart from the pure
	core of Prolog -- for example we include what are sometimes referred to
	as the meta-logical features.</dd>
      <dt id="footnote-6">6</dt>
      <dd>We include the word “relevant” here because in many cases there may be
	many possible acceptable solutions — and in such cases the requirements
	can be ambiguous in that regard, however that is not considered to be a
	“relevant” ambiguity, i.e. it does not correspond to an erroneous
	omission from the requirements.</dd>
      <dt id="footnote-7">7</dt>
      <dd>In the presence of <em>irrelevant</em> ambiguities this will mean that
    the infrastructure must choose one of the possibilities, or perhaps even
    provide all possible solutions.</dd>
      <dt id="footnote-8">8</dt>
      <dd>this assumption is generally known as the “synchrony hypothesis.”</dd>
      <dt id="footnote-9">9</dt>
      <dd>Care must be taken that the resulting reduction rules
    are <em>confluent</em> and <em>terminating</em>.</dd>
      <dt id="footnote-10">10</dt>
      <dd>because it can make the <em>logic</em> easier to express — as
    we shall see in <a href="section-7.html#section-7.3.2" class="calibre2">
	  section 7.3.2</a></dd>
      <dt id="footnote-11">11</dt>
      <dd>We are implicitly considering time as an additional input.</dd>
      <dt id="footnote-12">12</dt>
      <dd>There <em>is</em> some limited similarity between our goal of “Separate”
    and the goal of <em>separation of concerns</em> as promoted by proponents of Aspect
    Oriented Programming — but as we shall see
    in <a href="section-7.html#section-7.3.2" class="calibre2">section 7.3.2</a>, exactly what is meant by separation is critical.</dd>
      <dt id="footnote-13">13</dt>
      <dd>indeed it should be perfectly possible for different users of the same
    essential system to employ different accidental components — each designed
    for their particular needs</dd>
      <dt id="footnote-14">14</dt>
      <dd>or different subsets of the same language, provided it is
    possible to forcibly restrict each component to the relevant subset.</dd>
      <dt id="footnote-"></dt>
      <dd></dd>
    </dl>
  </body>
</html>
