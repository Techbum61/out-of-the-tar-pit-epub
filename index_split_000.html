<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Out of the Tar Pit</title>
    <meta name="generator" content="pdftohtml 0.36"/>
    <meta name="author" content="Ben Moseley and Peter Marks"/>
    <meta name="keywords" content="Complexity, SoftwareEngineering, RelationalModel, Functional, FunctionalProgramming"/>
    <meta name="date" content="2006-02-06T19:40:17+00:00"/>
    <meta name="subject" content="Complexity"/>
    <meta content="http://www.w3.org/1999/xhtml; charset=utf-8" http-equiv="Content-Type"/>
  <link href="stylesheet.css" type="text/css" rel="stylesheet"/><style type="text/css">
		@page { margin-bottom: 5.000000pt; margin-top: 5.000000pt; }</style></head>
  <body class="calibre">
    <p id="dummy"></p>

        <p class="calibre1" id="section11">11</p>

    <p class="calibre1">Related Work</p>

    <p class="calibre1">FRP draws some influence from the ideas
    of <a href="index_split_000.html#dummy" class="calibre2">[DD00]. </a></p>

    <p class="calibre1">In contrast with</p>

    <p class="calibre1">this work however, FRP is aimed at general purpose,
    large-scale application programming.</p>

    <p class="calibre1">Additionally FRP focuses on a separate, functional,
    sub-language and has different ideas about the use of types. Finally the
    accidental component of FRP has a broader range than the physical / logical
    mapping of traditional DBMSs.</p>

    <p class="calibre1">There are also some similarities to Backus’ Applicative
    State Transition systems <a href="index_split_000.html#dummy"
    class="calibre2">[Bac78], </a>and to the Aldat project at
    McGill <a href="index_split_000.html#dummy"
    class="calibre2">[Mer85] </a>which investi-gated general purpose
    applications of relational algebra.</p>

    <p class="calibre1">63</p>
 <p class="calibre1"/>
    <p class="calibre1" id="section12">12</p>

    <p class="calibre1">Conclusions</p>

    <p class="calibre1">We have argued that complexity causes more problems in
    large software systems than anything else. We have also argued that it can
    be tamed</p>

    <p class="calibre1">— but only through a concerted effort to avoid it where
    possible, and to separate it where not. Specifically we have argued that a
    system can usefully be separated into three main parts: the essential state,
    the essential logic, and the accidental state and control.</p>

    <p class="calibre1">We believe that taking these principles and applying
    them to the top level of a system design — effectively using different
    specialised languages for the different components — can offer more in terms
    simplicity than can the unstructured adoption of any single general language
    (be it imperative, logic or functional). In making this argument we briefly
    surveyed each of the common programming paradigms, paying some attention to
    the weaknesses of object-orientation as a particular example of an
    imperative approach.</p>

    <p class="calibre1">In cases (such as existing large systems) where this
    separation cannot be directly applied we believe the focus should be on
    avoiding state, avoiding explicit control where possible, and striving at
    all costs to get rid of code.</p>

    <p class="calibre1">So, what is the way out of the tar pit? What is the
    silver bullet? . . . it may not be FRP, but we believe there can be no doubt
    that it is simplicity.</p>

    <p class="calibre1">66</p>


<p class="calibre1"/>
<p class="calibre1"><a class="calibre3" id="outline"></a></p></body></html>
